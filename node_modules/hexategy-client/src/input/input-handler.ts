/**
 * InputHandler — gestió de clicks i arrossegaments per planificar ordres.
 *
 * Botó esquerre en regió pròpia + arrossegar a veïna → planificar moviment.
 * Botó dret en regió pròpia + arrossegar a regió amb ordre → eliminar aquell ordre.
 * Botó dret (mousedown + mouseup a la mateixa casella) → menú contextual de la regió.
 * Botó central → desplaçament de càmera (gestionat per Camera).
 */

import { Region, MoveOrder } from "../network/protocol.js";
import { HexRenderer } from "../render/hex-renderer.js";
import { Camera } from "../render/camera.js";
import { hexToPixel } from "../render/hex-renderer.js";

export type OrderChangeCallback = (orders: MoveOrder[]) => void;
export type ContextMenuCallback = (region: Region, clientX: number, clientY: number) => void;

export class InputHandler {
  private canvas: HTMLCanvasElement;
  private hexRenderer: HexRenderer;
  private camera: Camera;

  private myPlayerId: string;
  private regions: Region[] = [];
  private orders: MoveOrder[] = [];

  // ─── Drag esquerre (planificar ordre) ─────────────────────────────────────
  private isDragging = false;
  private dragFrom: Region | null = null;
  private dragCurrentPixel: { x: number; y: number } | null = null;

  // ─── Drag / clic dret (eliminar ordre / menú contextual) ──────────────────
  private rightDragFrom: Region | null = null;    // origen del drag dret (regió pròpia)
  private rightDownRegion: Region | null = null;  // regió on s'ha premut el botó dret

  private onOrderChange: OrderChangeCallback;
  private onDragFrame: ((from: { x: number; y: number }, to: { x: number; y: number }) => void) | null = null;
  private onRightDragFrame: ((from: { x: number; y: number } | null, to: { x: number; y: number } | null, targetRegionId: string | null) => void) | null = null;
  private onContextMenuCb: ContextMenuCallback | null = null;

  constructor(
    canvas: HTMLCanvasElement,
    hexRenderer: HexRenderer,
    camera: Camera,
    myPlayerId: string,
    onOrderChange: OrderChangeCallback
  ) {
    this.canvas = canvas;
    this.hexRenderer = hexRenderer;
    this.camera = camera;
    this.myPlayerId = myPlayerId;
    this.onOrderChange = onOrderChange;

    this.attachEvents();
  }

  updateState(regions: Region[], orders: MoveOrder[]): void {
    this.regions = regions;
    this.orders = orders;
  }

  /** Callback cridat en cada frame de drag esquerre (per dibuixar la fletxa de cursor). */
  onDrag(cb: (from: { x: number; y: number }, to: { x: number; y: number }) => void): void {
    this.onDragFrame = cb;
  }

  /** Callback cridat en cada frame de drag dret (per dibuixar la fletxa d'eliminació). */
  onRightDrag(cb: (from: { x: number; y: number } | null, to: { x: number; y: number } | null, targetRegionId: string | null) => void): void {
    this.onRightDragFrame = cb;
  }

  /** Callback cridat quan l'usuari fa clic dret sobre una regió (mateixa casella). */
  onContextMenu(cb: ContextMenuCallback): void {
    this.onContextMenuCb = cb;
  }

  private attachEvents(): void {
    this.canvas.addEventListener("mousedown",   this.onMouseDown, { capture: true });
    this.canvas.addEventListener("mousemove",   this.onMouseMove);
    window.addEventListener("mouseup",          this.onMouseUp);
    this.canvas.addEventListener("contextmenu", this.preventContextMenu);
    this.canvas.addEventListener("touchstart",  this.onTouchStart, { passive: false });
    this.canvas.addEventListener("touchmove",   this.onTouchMove,  { passive: false });
    this.canvas.addEventListener("touchend",    this.onTouchEnd);
  }

  detach(): void {
    this.canvas.removeEventListener("mousedown",   this.onMouseDown, { capture: true });
    this.canvas.removeEventListener("mousemove",   this.onMouseMove);
    window.removeEventListener("mouseup",          this.onMouseUp);
    this.canvas.removeEventListener("contextmenu", this.preventContextMenu);
    this.canvas.removeEventListener("touchstart",  this.onTouchStart);
    this.canvas.removeEventListener("touchmove",   this.onTouchMove);
    this.canvas.removeEventListener("touchend",    this.onTouchEnd);
  }

  // ─── Ratolí ───────────────────────────────────────────────────────────────

  private onMouseDown = (e: MouseEvent): void => {
    if (e.button === 0) {
      // Botó esquerre: inici de drag per planificar ordre
      const pos = this.canvasPos(e);
      const region = this.hexRenderer.regionAt(pos.x, pos.y, this.regions);
      if (!region || region.ownerId !== this.myPlayerId) return;

      this.isDragging = true;
      this.dragFrom = region;
      this.dragCurrentPixel = pos;
      this.hexRenderer.selectedRegionId = region.id;
      this.hexRenderer.highlightedRegionIds = new Set(region.neighbors);

    } else if (e.button === 2) {
      // Botó dret: registrar la regió d'origen (per distingir clic vs. drag)
      const pos = this.canvasPos(e);
      const region = this.hexRenderer.regionAt(pos.x, pos.y, this.regions);
      this.rightDownRegion = region ?? null;
      // Només iniciem drag dret des de regions pròpies (per eliminar ordres)
      if (region?.ownerId === this.myPlayerId) {
        this.rightDragFrom = region;
        // Bloquejar el pan de càmera: volem arrossegar per eliminar un ordre, no moure la vista
        this.camera.blockRightPan(true);
      }
    }
  };

  private onMouseMove = (e: MouseEvent): void => {
    const pos = this.canvasPos(e);

    if (this.isDragging && this.dragFrom) {
      this.dragCurrentPixel = pos;
      const fp    = hexToPixel(this.dragFrom.coord.q, this.dragFrom.coord.r);
      const world = this.camera.canvasToWorld(pos.x, pos.y);
      this.onDragFrame?.(fp, world);
    }

    if (this.rightDragFrom) {
      const fp    = hexToPixel(this.rightDragFrom.coord.q, this.rightDragFrom.coord.r);
      const world = this.camera.canvasToWorld(pos.x, pos.y);
      const hovered = this.hexRenderer.regionAt(pos.x, pos.y, this.regions);
      const isValidTarget = hovered !== null
        && hovered.id !== this.rightDragFrom.id
        && this.rightDragFrom.neighbors.includes(hovered.id)
        && this.orders.some((o) => o.fromRegionId === this.rightDragFrom!.id && o.toRegionId === hovered.id);
      this.onRightDragFrame?.(fp, world, isValidTarget ? hovered!.id : null);
    }
  };

  private onMouseUp = (e: MouseEvent): void => {
    if (e.button === 0) {
      // Botó esquerre: confirmar ordre si s'ha arrossegat a un veí
      if (!this.isDragging || !this.dragFrom) return;
      const pos    = this.canvasPos(e);
      const target = this.hexRenderer.regionAt(pos.x, pos.y, this.regions);

      if (target && target.id !== this.dragFrom.id && this.dragFrom.neighbors.includes(target.id)) {
        this.createOrUpdateOrder(this.dragFrom, target);
      }
      this.endDrag();

    } else if (e.button === 2) {
      // Si no hi havia cap drag dret actiu, ignorar (evitar falsos positius)
      if (!this.rightDownRegion && !this.rightDragFrom) return;

      const pos    = this.canvasPos(e);
      const target = this.hexRenderer.regionAt(pos.x, pos.y, this.regions);

      if (target && this.rightDownRegion?.id === target.id) {
        // Mateixa casella → menú contextual
        this.onContextMenuCb?.(target, e.clientX, e.clientY);

      } else if (this.rightDragFrom && target && target.id !== this.rightDragFrom.id) {
        // Casella diferent → eliminar l'ordre concret d'origen → destí
        this.removeOrder(this.rightDragFrom.id, target.id);
      }

      this.rightDragFrom   = null;
      this.rightDownRegion = null;
      this.camera.blockRightPan(false);
      this.onRightDragFrame?.(null, null, null); // netejar feedback visual
    }
  };

  /** Evita que el navegador mostri el seu propi menú contextual sobre el canvas. */
  private preventContextMenu = (e: MouseEvent): void => {
    e.preventDefault();
  };

  // ─── Touch ────────────────────────────────────────────────────────────────

  private onTouchStart = (e: TouchEvent): void => {
    if (e.touches.length !== 1) return;
    e.preventDefault();
    const pos    = this.touchPos(e.touches[0]);
    const region = this.hexRenderer.regionAt(pos.x, pos.y, this.regions);
    if (!region || region.ownerId !== this.myPlayerId) return;

    this.isDragging = true;
    this.dragFrom   = region;
    this.hexRenderer.selectedRegionId    = region.id;
    this.hexRenderer.highlightedRegionIds = new Set(region.neighbors);
  };

  private onTouchMove = (e: TouchEvent): void => {
    if (!this.isDragging || !this.dragFrom || e.touches.length !== 1) return;
    e.preventDefault();
    const pos   = this.touchPos(e.touches[0]);
    this.dragCurrentPixel = pos;
    const fp    = hexToPixel(this.dragFrom.coord.q, this.dragFrom.coord.r);
    const world = this.camera.canvasToWorld(pos.x, pos.y);
    this.onDragFrame?.(fp, world);
  };

  private onTouchEnd = (_e: TouchEvent): void => {
    if (!this.isDragging || !this.dragFrom) return;
    if (this.dragCurrentPixel) {
      const target = this.hexRenderer.regionAt(
        this.dragCurrentPixel.x,
        this.dragCurrentPixel.y,
        this.regions
      );
      if (target && target.id !== this.dragFrom.id && this.dragFrom.neighbors.includes(target.id)) {
        this.createOrUpdateOrder(this.dragFrom, target);
      }
    }
    this.endDrag();
  };

  // ─── Lògica d'ordres ──────────────────────────────────────────────────────

  private createOrUpdateOrder(from: Region, to: Region): void {
    const existing = this.orders.find(
      (o) => o.fromRegionId === from.id && o.toRegionId === to.id
    );
    if (existing) return; // ja existeix

    // Distribució equitativa: (tropes − 1) / (ordres existents + 1)
    const ordersFromSame = this.orders.filter((o) => o.fromRegionId === from.id);
    const available      = Math.max(0, from.troops - 1);
    const perOrder       = Math.floor(available / (ordersFromSame.length + 1));

    for (const o of ordersFromSame) o.troops = perOrder;
    this.orders.push({ fromRegionId: from.id, toRegionId: to.id, troops: perOrder });
    this.onOrderChange([...this.orders]);
  }

  /** Elimina l'ordre específic de `fromId` → `toId`. */
  private removeOrder(fromId: string, toId: string): void {
    const before = this.orders.length;
    this.orders  = this.orders.filter(
      (o) => !(o.fromRegionId === fromId && o.toRegionId === toId)
    );
    if (this.orders.length !== before) this.onOrderChange([...this.orders]);
  }

  private endDrag(): void {
    this.isDragging       = false;
    this.dragFrom         = null;
    this.dragCurrentPixel = null;
    this.onDragFrame?.({ x: 0, y: 0 }, { x: 0, y: 0 }); // netejar fletxa de drag
    this.hexRenderer.selectedRegionId     = null;
    this.hexRenderer.highlightedRegionIds = new Set();
  }

  // ─── Helpers ──────────────────────────────────────────────────────────────

  private canvasPos(e: MouseEvent): { x: number; y: number } {
    const rect = this.canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  private touchPos(t: Touch): { x: number; y: number } {
    const rect = this.canvas.getBoundingClientRect();
    return { x: t.clientX - rect.left, y: t.clientY - rect.top };
  }
}
